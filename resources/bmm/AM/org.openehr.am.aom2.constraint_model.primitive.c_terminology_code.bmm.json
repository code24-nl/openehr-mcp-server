{
    "name": "C_TERMINOLOGY_CODE",
    "documentation": "Constrainer type for instances of `Terminology_code`. The constraint attribute can contain:\n\n* a single at-code\n* a single ac-code, representing a value-set that is defined in the archetype terminology\n\nIf there is an assumed value for the ac-code case above, the `_assumed_value_` attribute contains a single at-code, which must come from the list of at-codes defined as the internal value set for the ac-code.\n\nThe `_constraint_status_` attribute and `_constraint_required_()` function together define whether the `_constraint_` is considered formal ('required') or not. In the non-required cases, a data-item matched to this constraint may be any coded term.",
    "ancestors": [
        "C_PRIMITIVE_OBJECT"
    ],
    "properties": {
        "constraint": {
            "name": "constraint",
            "documentation": "Type of individual constraint - a single string that can either be a local at-code, or a local ac-code signifying a locally defined value set. If an ac-code, assumed_value may contain an at-code from the value set of the ac-code.\n\nUse an empty string for no constraint.",
            "is_mandatory": true,
            "type": "String"
        },
        "assumed_value": {
            "name": "assumed_value",
            "documentation": "Assumed Terminology code value.",
            "type": "Terminology_code"
        },
        "default_value": {
            "name": "default_value",
            "type": "Terminology_code"
        },
        "constraint_status": {
            "name": "constraint_status",
            "documentation": "Constraint status of this terminology constraint. If Void, the meaning is as follows:\n\n* in a top-level  archetype, equivalent to `required`;\n* in a specialised (source) archetype, the meaning is to inherit the value from the corresponding node in the parent.\n\nIn the case of a specialised archetype generated by flattening, the value of this field will be:\n\n* Void if it was Void in the parent;\n* otherwise, it will carry the same value as in the parent.",
            "type": "CONSTRAINT_STATUS"
        }
    },
    "functions": {
        "constraint_required": {
            "name": "constraint_required",
            "documentation": "True if `_constraint_status_` is defined and equals `required` OR if Void. I.e. in archetypes where `C_TERMINOLOGY_CODE` instances have no `_constraint_status_`, the `required` status is assumed, which applies to all legacy archetypes.",
            "result": {
                "type": "Boolean"
            }
        },
        "effective_constraint_status": {
            "name": "effective_constraint_status",
            "documentation": "Return the effective integer value of the `_constraint_status_` field if it exists. If it is null, return 0, i.e. `required`.\n\nNOTE: the above logic applies to any `C_TERMINOLOGY_NODE` instance in a specialised archetype that redefines another such instance in the flat parent. I.e. no stated `_constraint_status_` means `required`.",
            "result": {
                "type": "Integer"
            }
        },
        "value_set_expanded": {
            "name": "value_set_expanded",
            "documentation": "Effective set of at-code values corresponding to an ac-code for a locally defined value set. Not defined for ac-codes that have no local value set.",
            "result": {
                "_type": "P_BMM_CONTAINER_TYPE",
                "container_type": "List",
                "type": "String"
            },
            "is_nullable": true
        },
        "value_set_substituted": {
            "name": "value_set_substituted",
            "documentation": "For locally defined value sets within individual code bindings: return the term URI(s) substituted from bindings for local at-codes in `_value_set_expanded_`.",
            "result": {
                "_type": "P_BMM_CONTAINER_TYPE",
                "container_type": "List",
                "type": "Uri"
            },
            "is_nullable": true
        },
        "value_set_resolved": {
            "name": "value_set_resolved",
            "documentation": "For locally defined value sets within individual code bindings: final set of external codes to which value set is resolved.",
            "result": {
                "_type": "P_BMM_CONTAINER_TYPE",
                "container_type": "List",
                "type": "Terminology_code"
            },
            "is_nullable": true
        },
        "valid_value": {
            "name": "valid_value",
            "documentation": "True if a `_value_` is valid with respect to constraint expressed in concrete instance of this type. ",
            "parameters": {
                "a_value": {
                    "name": "a_value",
                    "type": "Terminology_code"
                }
            },
            "result": {
                "type": "Boolean"
            }
        },
        "prototype_value": {
            "name": "prototype_value",
            "documentation": "A generated prototype value from this constraint object.",
            "result": {
                "type": "Terminology_code"
            }
        },
        "any_allowed": {
            "name": "any_allowed",
            "documentation": "True if `_constraint_` is empty.",
            "post_conditions": {
                "Post": "Result := constraint.is_empty"
            },
            "result": {
                "type": "Boolean"
            }
        },
        "c_value_conforms_to": {
            "name": "c_value_conforms_to",
            "documentation": "True if `_other.any_allowed_` or else every constraint in the `_constraint_` list exists in the `_other.constraint_`, and `_effective_constraint_status()_` is <= `_other.effective_constraint_status()_`.",
            "parameters": {
                "other": {
                    "name": "other",
                    "type": "C_TERMINOLOGY_CODE"
                }
            },
            "result": {
                "type": "Boolean"
            }
        },
        "c_value_congruent_to": {
            "name": "c_value_congruent_to",
            "documentation": "True if `_constraint_` and `_other.constraint_` are both value-set ids, and expand to identical value sets, or else are identical value codes; and `_effective_constraint_status()_` = `_other.effective_constraint_status()_`.",
            "parameters": {
                "other": {
                    "name": "other",
                    "type": "C_TERMINOLOGY_CODE"
                }
            },
            "result": {
                "type": "Boolean"
            }
        }
    }
}
